# **erilog 반복문**

# **반복문의 종류**

Verilog에서 주로 사용하는 반복문의 종류는 총 5개로 **for, while, repeat, forever, generate for** 이렇게 5개이다. 상황에 따라 쓰이는 반복문이 다릅니다.

### **for문**

Verilog에서 for문은 **가장 많이 쓰이는 반복문**이라고 해도 좋은 반복문입니다. 중괄호 대신 begin, end를 사용하고, C언어의 **for문과 유사**하며 **always문 안에 작성**해야 한다는 특징과 반복 횟수가 **상수**로 되어있어야 한다는 특징을 가지고 있습니다. 예시 코드를 보자면

```cpp
integer i;
always @(posedge clk) begin // always문 안에 작성
    for (i = 0; i < 8; i = i + 1) begin
        data_out[i] <= data_in[7-i];
    end
end
```

이렇게 작성할 수 있습니다.

### **while문**

**조건이 참인 동안 실행되는 반복문**으로 for문과 마찬가지로 **C언어의 while문과 유사**하며 중괄호 대신 begin, end를 사용합니다. 예시 코드를 보자면

```cpp
initial begin
    while (error == 0) begin
        #10 data= data + 1;
    end
end
```

이렇게 작성할 수 있습니다. (주로 시뮬레이션에서 사용)

### **repeat문**

repeat문은 지정된 횟수만큼 반복하는 반복문입니다. 예시 코드를 보자면

```cpp
initial begin
    reset = 1;
    #20 reset = 0;

    repeat (10) begin // 반복 횟수 지정
        @(posedge clk);
        data_in = data_in + 1;
    end

    $finish;
end
```

이렇게 작성할 수 있습니다. (주로 시뮬레이션에서 사용)

### **forever문**

forever문은 탈출 조건 없이 무한히 반복하는 반복문입니다. 탈출을 하지 않기에 거의 모니터링에만 쓰이는 반복문입니다. 예시 코드를 보자면

```cpp
initial begin
    clk = 0;
    forever begin
        #5 clk = ~clk; // 무한 반복
    end
end
```

이렇게 작성할 수 있습니다. (주로 모니터링에서 사용)

### **generate for문**

generate for문은 **하드웨어 인스턴스** 즉 모듈, 게이트등을 **복사할 때 주로 사용**합니다. **always문 대신 generate를 사용**합니다. 또한 **for문에 사용하는 변수를 genvar변수**로 사용해야합니다. 예시 코드를 보자면

```cpp
genvar j; // integer대신 사용
generate // always문 대신 사용
    for (j = 0; j < 4; j = j + 1) begin : bit_assign
        assign out[j] = in1[j] & in2[j];
    end
endgenerate
```

이렇게 작성할 수 있습니다.

# **총정리**

| **구분** | 종류 | 합성 가능 여부 | 사용처 |
| --- | --- | --- | --- |
| **설계용** | for, generate for | O | 비트 연산, 모듈 복사, 병렬 회로 생성 |
| **검증용** | while, repeat | X | 테스트 벤치, 데이터 전송 |
| **특수용** | forever | X | 모니터링 |

# **마무리**

이렇게 반복문의 종류와 반복문들의 사용 용도를 알아보았습니다. 반복문의 용도를 햇갈리셔서 테스트벤치에 설계용 반복문을 사용한다던가 모니터링이 아닌 곳에 forever문을 사용하시는 실수를 하지 않도록 조심하시면 좋겠습니다. 그럼 임베디드를 정복하시길 바라면서 마치겠습니다 감사합니다.

# Verilog 생성문

# **생성문을 언제 쓸까?**

Verilog의 생성문은 **하드웨어 구조를 조건에 따라 선택하거나, 반복적인 로직을 간결하게 기술할 때 사용하는 구문**입니다. 생성문의 종류는 **generate for, generate if, generate case**이렇게 총 3개가 있습니다. 여기서 공통점은 원래 구문 앞에 **generate**가 붙습니다.

### **generate for문**

generate for문은 반복문으로 분류 되기도 하지만 생성문에도 포함됩니다. generate for문은 **모듈이나 로직(예: primitive, net, assignment)을 여러 번 반복해서 배치해야 할 때 사용**하며 **always문 대신 generate를 사용**합니다. 또한 for문에 사용하는 변수를 **genvar변수로 사용**해야합니다. 예시 코드를 보자면

```cpp
genvar i; // integer 대신 사용
generate
    for (i = 0; i < 4; i = i + 1) begin : bit_loop
        full_adder fa (
            .a(a[i]),
            .b(b[i]),
            .cin(carry[i]),
            .sum(sum[i]),
            .cout(carry[i+1])
        );
    end
endgenerate
```

이렇게 작성할 수 있습니다.

### **generate if문**

generate if문은 **조건에 따라 특정 모듈의 포함 여부를 판단**합니다. 주로 **파라미터에 따른 알고리즘 선택에 사용**합니다. 예를 들면 CLA 가산기, Ripple Carry 가산기등에 많이 사용합니다. CLA 가산기 코드로 예시를 들어보면

```cpp
generate
    if (USE_CLA == 1) begin : adder_inst
        cla_adder adder_0 (a, b, sum);
    end else begin : adder_inst
        ripple_adder adder_0 (a, b, sum);
    end
endgenerate
```

이렇게 작성할 수 있습니다.

### **generate case문**

generate case문은 generate if문과 유사하지만 **여러가지 옵션을 선택해야 할 때 유리**합니다. 데이터 폭이나 특정 **아키텍처 모드에 따른 로직 분기**를 위해 사용됩니다. 예시 코드를 보자면

```cpp
parameter MODE = 1;

generate
    case (MODE)
        0: begin : gen_mod  // MODE가 0일 때
            assign out = a & b;
        end
        1: begin : gen_mod  // MODE가 1일 때
            assign out = a | b;
        end
        default: begin : gen_mod
            assign out = a ^ b;
        end
    endcase
endgenerate
```

이렇게 작성할 수 있겠습니다.

# **마무리**

이렇게 Verilog의 귀찮음 해결사 생성문을 알아봤습니다. 사용할때 generate를 앞에 작성하는 생성문은 원래있던 for, if, case문과 유사한 구성을 가지고 있기 때문에 특성만 외워둔다면 어려울 일은 없을 것이라고 생각합니다. 그럼 임베디드의 정복자가 되시길 바라면서 마치겠습니다 감사합니다.
