# Verilog 할당문

# **할당문이 무엇일까?**

**프로그래밍에서 변수에 값을 부여하거나 변경하는 명령문**입니다. Verilog에서는 크게 두 가지로 나뉘며 하는 설계가 **조합 회로, 순차 회로**에 따라 사용하는 방식이 다릅니다. **조합 회로는 주로 연속 할당문**을 사용하고, **순차 회로는 주로 절차적 할당문**을 사용합니다.

# **연속 할당문(assign)**

연속 할당문은 assign 키워드를 사용합니다. 여기서 주의점은 반드시 **wire 자료형에 할당**해야 한다는 것 입니다. 특징으로는 우변의 값이 변하면 좌변의 값이 **즉각적으로 업데이트** 된다는 특징이 있습니다.

```bash
wire out;
assign out = a & b; // a 또는 b가 변하면 out은 즉시 변함
```

# **절차적 할당문(always, initial)**

always 블록이나 initial블록 내부에서 사용하며, 레지스터 자료형에 값을 할당할 때 사용합니다. 방법이 2가지가 있으며 첫번째는 **블로킹 할당**, 두번째는 **논블로킹 할당**이 있습니다.

### **블로킹 할당**

블로킹 할당은 **코드의 순서대로 실행**되며 **한 줄의 실행이 끝나야 다음 줄로 넘어간다는 특징**을 가지고 있습니다. 주로 always @(*)블록 내에서 **조합 회로를 설계할 때 사용**합니다. 여기서 의문점은 아까 위에서 절차적 할당문은 순차 회로에서 주로 사용된다고 했는데 왜 갑자기 여기서 조합 회로를 설계할 때 사용하냐면 **거의 always @(*) 블록 위에서만 사용**하기 때문입니다.

코드의 예시를 들자면

```bash
always @(*) begin
    temp = a + b;
    out = temp + c; // temp 값이 결정된 후 out이 계산됨
end
```

이렇게 작성할 수 있겠습니다.

### **논블로킹 할당**

논블로킹 할당은 **블록 내의 모든 할당이 동시에 일어난다는 특징**이 있습니다. 현재 상태의 값을 읽어온 뒤, 블록이 끝나는 시점에 한꺼번에 업데이트합니다. **순차 회로** 즉 Flip-Flop이나 Register를 설계할 때 필수적으로 사용합니다.

코드의 예시를 들자면

```bash
always @(posedge clk) begin
    a <= b;
    b <= a; // a와 b의 값이 서로 교환됨 (동시 업데이트)
end
```

이렇게 작성할 수 있겠습니다.

# **총정리**

| **구분** | **연속 할당** | **블로킹 할당** | **논블로킹 할당** |
| --- | --- | --- | --- |
| **키워드** | assign | = | <= |
| **블록** | 블록 외부 | always, initial 내부 | always, initial 내부 |
| **자료형** | wire | reg | reg |
| **회로 종류** | 조합 회로 | 조합 회로 | 순차 회로 |

# **마무리**

Verilog에서 할당문은 거의 길을 지나가며 김씨를 만날 확률만큼 높기 때문에 사용방법 쯤은 외워두시는 것을 추천드립니다. 임베디드를 정복하시길 바라시면서 마치겠습니다 감사합니다.

# Verilog always문

# **always문을 왜 사용할까?**

Verilog의 always문은 **특정한 조건을 만족하면 실행되는 특징**을 가지고 있습니다. 그럼 여기서 의문점이 생기는데요 조건문은 어따 버리고 always문을 써? 라고 하실 수 있습니다. 여기의 답은 **조건문은 always문 안에서 작성**되며 always문의 조건에 따라 역할이 달라지기에 조건문과는 비교하기 어렵습니다.

# **기본 구조**

```bash
always @(조건) begin
    // 실행될 로직
end
```

위와 같이 always문은 @ 작성 후 괄호 안에 조건을 넣는 구조를 가지고 있습니다. **조건이 바뀌는 순간** always문이 실행되며 안에있는 로직이 실행됩니다.

### **조합 회로**

**입력 신호가 바뀌면 즉시 결과가 변하는 회로**입니다. always의 조건 안에 *** 을 넣어서 사용**하며 가산기, 멀티플렉서등을 만들때 사용합니다. 특징으론 **블로킹 할당(=)을 이용**합니다. 예시 코드를 보자면

```bash
// 모든 입력 변화에 반응
always @(*) begin
    sum = a + b; // 블로킹 할당
end
```

이와 같습니다.

### **순차 회로**

**클럭(Clock) 신호에 맞춰 값이 변하는 회로**입니다. always의 조건 안에 **posedge, negedge**를 넣어서 사용하며 플립플롭, 카운터등을 만들때 사용합니다. 특징으론 **논블로킹 할당(<=)을 이용**합니다. 예시 코드를 보자면

```bash
// 클럭이 0에서 1로 올라갈 때만 작동
always @(posedge clk) begin
    q <= d; // 논블로킹 할당
end
```

이와 같습니다.

# **규칙**

1. always문 안에서 값이 할당되는 변수는 반드시 **reg타입으로 선언**해야한다.
2. **조합 회로에서는 블로킹 할당**을 이용하고, **순차 회로에서는 논블로킹 할당**을 이용해야한다.
3. 조합 회로를 만들때 if나 case문에서 **모든 경우의 수를 지정하지 않는다면 의도치 않은 메모리가 생성**되어 **레치 상태가 발생**합니다.

# **마무리**

이렇게 always문이 무엇인지 조합 회로, 순차 회로에서는 어떻게 사용하는지 always문을 사용할때 지켜야하는 규칙들을 알아보았습니다. always문을 많이 사용하는 Verilog에서 always문을 까먹거나 규칙들을 까먹는다면 매우 곤란해지겠죠? 그러니 여러분들은 확실히 외우고 넘어가는 것을 추천합니다. 그럼 임베디드를 정복하시길 바라면서 마치겠습니다 감사합니다.
