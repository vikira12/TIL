# Verilog 상수

# **숫자 표현 방식**

verilog에서의 숫자는 우리가 사용하는 숫자와는 조금 다른 방식을 사용합니다. **크기, 진법, 값으로 구성**되며 사용자가 사용하고자 하는 숫자를 알맞게 조합하여 사용합니다. <size>'<base><number>의 형태를 가지고 **size는 설정하지 않으면 32비트**가 기본값이 됩니다. 베이스는 4가지 종류를 가지며 아래과 같이 형성되어 있습니다.

- 'b: 2진수 (Binary)
- 'o: 8진수 (Octal)
- 'd: 10진수 (Decimal)
- 'h: 16진수 (Hexadecimal)

### **예시**

- 8'b10100101 // 8비트 2진수 165
- 16'hFF00 // 16비트 16진수 65,280
- 7 // 크기가 지정되지 않은 10진수 7 (자동으로 32비트를 가짐)

# **상수 정의 방법**

숫자 표현 방식을 알았으니 상수 정의 방법을 알아보자면, 총 세 가지 주요 방법이 있습니다.

### **1. parameter (모듈 내 상수)**

모듈 내부에서 사용되는 상수로, 모듈을 인스턴스화(독립 객체 생성)할 때 **값을 변경**할 수 있다. 라는 특징이 있습니다.

```bash
module Counter #(parameter LIMIT = 100) (
    input clk,
    output reg [7:0] out
);
    // LIMIT은 이 모듈 안에서 상수로 사용
endmodule
```

### **2. `define (전역 매크로)**

컴파일의 지시어로 C언어의 #define과 같은 역할을 수행합니다. C언어와의 다른점은 #대신 백틱(`)을 붙여야 한다는 다른점이 존재합니다.

```bash
`define STATE_IDLE 2'b00
`define STATE_RUN  2'b01

// 사용 시
state <= `STATE_IDLE; // 논블록킹 할당
```

### **3. localparam (지역 상수)**

parameter와 비슷하지만, 모듈 외부에서 값을 수정할 수 없다는 차별점이 존재합니다. 모듈 내부의 고유한 상수를 보호하고 싶을 때 사용합니다.

```bash
module Control;
    localparam PI = 3.14; // 외부에서 변경 불가
endmodule
```

# **총정리**

| **구분** | 유효 범위 | 외부 변경 가능 여부 | 특징 |
| --- | --- | --- | --- |
| **parameter** | 모듈 내부 | 가능 | 모듈 재사용 시 설정값 변경에 유리 |
| **localparam** | 모듈 내부 | 불가능 | 내부 설계 보호 및 고정값 정의 |
| **`define** | 프로젝트 전체 | 불가능 | 전역적인 설정(디버그 모드 등)에 사용 |

# **마무리**

이렇게 Verilog의 상수에 대해 알아봤습니다. 숫자를 사용하는 방법이 조금 특이하여 적응이 힘들 수 있지만 size, base, number이 순서를 기억하시며 사용하시면 좋겠습니다.임베디드를 정복하시길 바라면서 마치겠습니다 감사합니다!

# Verilog 모듈(module)

# **모듈(module)이 뭘까?**

Verilog에서 모듈은 **설계를 구성하는 가장 기본적인 단위**입니다. 모듈을 사용하는 이유로는 **복잡한 디지털 시스템을 계층적으로 설계 하도록 도와주는 친구**이기에 Verilog에서 빼놓을 수 없는 요소입니다.

# **모듈의 기본 구조**

모듈은 **module** 키워드로 시작하여 **endmodule**로 끝납니다. 크게 **선언부, 입출력 정의, 내부 로직**의 세 부분으로 나뉘는 구조로 형성되어 있습니다. 모듈의 생김새를 보여주자면

```bash
module 모듈이름 (
    input  wire 입력1,
    input  wire 입력2,
    output wire 출력1
);

    // 내부 로직 (연산 및 데이터 흐름)

    assign 출력1 = 입력1 & 입력2; // 예: AND 게이트

endmodule
```

이런 생김새를 가지고 있습니다.

# **포트(Ports)**

포트의 선언부에서 사용하는 포트는 외부와 소통하는 통로로 종류는 총 3가지가 있습니다. **input(입력), output(출력), inout(양방향)**이 있으며 상황에 맞게 사용하면 됩니다.

# **계층적 설계**

큰 시스템을 만들 때는 **작은 모듈들을 만들고, 이를 상위 모듈에서 불러와서 연결**합니다. 이를 **인스턴스화**(Instantiation)라고 합니다. Verilog에서 코드의 길이가 길어질수록 절대 빼놓을 수 없는 요소입니다. 전가산기로 예시를 들어보면

```bash
module FullAdder (
    input a, b, cin,
    output sum, cout
);
    wire s1, c1, c2;

    // HalfAdder 모듈 호출 (인스턴스화)
    HalfAdder HA1 (a, b, s1, c1);
    HalfAdder HA2 (s1, cin, sum, c2);

    assign cout = c1 | c2;
endmodule
```

이런식으로 구현이 가능합니다.

# **마무리**

이렇게 Verilog에서 빼놓을 수 없는 모듈과 모듈로 하는 계층적 설계에 대해 알아 보았습니다. 이를 잘 이용하여 가독성 높은 코드를 만들어내길 응원합니다. 임베디드를 정복하시길 바라면서 마치겠습니다 감사합니다.

# Verilog 연산자

# **산술 연산자**

| **연산자** | 뜻 |
| --- | --- |
| **+** | 더하기 |
| **-** | 빼기 |
| ***** | 곱하기 |
| **/** | 나누기 |
| **%** | 나머지 |
| ****** | 거듭제곱 |

# **논리 연산자**

| **연산자** | 뜻 |
| --- | --- |
| **!** | Logical NOT |
| **&&** | Logical AND |
| **||** | Logical OR |

# **비트 단위 연산자**

| **연산자** | 뜻 |
| --- | --- |
| **~** | Bitwise NOT |
| **&** | Bitwise AND |
| **|** | Bitwise OR |
| **^** | Bitwise XOR |
| **~^ 또는 ^~** | Bitwise XNOR |

# **관계 및 등가 연산자**

| **연산자** | 뜻 |
| --- | --- |
| **>, <, >=, <=** | 크기 비교 |
| **==** | 값이 같은지 확인 |
| **!=** | 값이 다른지 확인 |
| **===** | x, z상태까지 포함하여 완전히 일치하는지 확인 |

# **축약 연산자**

| **연산자** | 뜻 |
| --- | --- |
| **&** | 모든 비트가 1이면 1 |
| **|** | 비트 중 하나라도 1이면 1 |
| **^** | 홀수 개의 비트가 1이면 1(패러티 체크에 많이 씀) |

# **시프트 연산자**

| **연산자** | 뜻 |
| --- | --- |
| **<<** | 왼쪽으로 비트를 밀어냄(빈자리는 0으로) |
| **>>** | 오른쪽으로 비트를 밀어냄(빈자리는 0으로) |
| **<<<, >>>** | 부호비트를 유지하며 시프트 |

# **삼항 연산자**

조건 ? 참일_때_값 : 거짓일_때_값

# **결합 및 복제 연산자**

| **연산자** | 뜻 |
| --- | --- |
| **{}** | 결합(안에 있는 내용을 이어붙임) |
| **{n{}}** | 반복(분배 법칙과 비슷함)ex : {4{1'b0}}은 4'b0000과 같음 |

# **마무리**

연산자는 딱히 설명할 내용이 많지 않아서 표로 깔끔하게 정리해 봤습니다. 연산자를 모두 외우지 않더라도 이런게 있었구나 라고 떠올리시면 좋겠습니다. 임베디드를 정복하시길 바라면서 마치겠습니다 감사합니다.

# Verilog 할당문

# **할당문이 무엇일까?**

**프로그래밍에서 변수에 값을 부여하거나 변경하는 명령문**입니다. Verilog에서는 크게 두 가지로 나뉘며 하는 설계가 **조합 회로, 순차 회로**에 따라 사용하는 방식이 다릅니다. **조합 회로는 주로 연속 할당문**을 사용하고, **순차 회로는 주로 절차적 할당문**을 사용합니다.

# **연속 할당문(assign)**

연속 할당문은 assign 키워드를 사용합니다. 여기서 주의점은 반드시 **wire 자료형에 할당**해야 한다는 것 입니다. 특징으로는 우변의 값이 변하면 좌변의 값이 **즉각적으로 업데이트** 된다는 특징이 있습니다.

```bash
wire out;
assign out = a & b; // a 또는 b가 변하면 out은 즉시 변함
```

# **절차적 할당문(always, initial)**

always 블록이나 initial블록 내부에서 사용하며, 레지스터 자료형에 값을 할당할 때 사용합니다. 방법이 2가지가 있으며 첫번째는 **블로킹 할당**, 두번째는 **논블로킹 할당**이 있습니다.

### **블로킹 할당**

블로킹 할당은 **코드의 순서대로 실행**되며 **한 줄의 실행이 끝나야 다음 줄로 넘어간다는 특징**을 가지고 있습니다. 주로 always @(*)블록 내에서 **조합 회로를 설계할 때 사용**합니다. 여기서 의문점은 아까 위에서 절차적 할당문은 순차 회로에서 주로 사용된다고 했는데 왜 갑자기 여기서 조합 회로를 설계할 때 사용하냐면 **거의 always @(*) 블록 위에서만 사용**하기 때문입니다.

코드의 예시를 들자면

```bash
always @(*) begin
    temp = a + b;
    out = temp + c; // temp 값이 결정된 후 out이 계산됨
end
```

이렇게 작성할 수 있겠습니다.

### **논블로킹 할당**

논블로킹 할당은 **블록 내의 모든 할당이 동시에 일어난다는 특징**이 있습니다. 현재 상태의 값을 읽어온 뒤, 블록이 끝나는 시점에 한꺼번에 업데이트합니다. **순차 회로** 즉 Flip-Flop이나 Register를 설계할 때 필수적으로 사용합니다.

코드의 예시를 들자면

```bash
always @(posedge clk) begin
    a <= b;
    b <= a; // a와 b의 값이 서로 교환됨 (동시 업데이트)
end
```

이렇게 작성할 수 있겠습니다.

# **총정리**

| **구분** | **연속 할당** | **블로킹 할당** | **논블로킹 할당** |
| --- | --- | --- | --- |
| **키워드** | assign | = | <= |
| **블록** | 블록 외부 | always, initial 내부 | always, initial 내부 |
| **자료형** | wire | reg | reg |
| **회로 종류** | 조합 회로 | 조합 회로 | 순차 회로 |

# **마무리**

Verilog에서 할당문은 거의 길을 지나가며 김씨를 만날 확률만큼 높기 때문에 사용방법 쯤은 외워두시는 것을 추천드립니다. 임베디드를 정복하시길 바라시면서 마치겠습니다 감사합니다.
